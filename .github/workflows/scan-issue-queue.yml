name: Scan Issue Queue

on:
  schedule:
    # Run daily at midnight UTC
    - cron: '0 0 * * *'
  workflow_dispatch:
    # Allow manual triggering

permissions:
  contents: write
  issues: write

jobs:
  scan-open-issues:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Fetch open SCAN issues
        id: fetch-issues
        uses: actions/github-script@v7
        with:
          script: |
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });

            const scanIssues = issues.filter(issue =>
              issue.title.startsWith('SCAN:') && !issue.pull_request
            );

            console.log(`Found ${scanIssues.length} open SCAN issues`);
            return scanIssues.map(issue => issue.number);
          result-encoding: json

      - name: Scan each issue
        if: steps.fetch-issues.outputs.result != '[]'
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync, spawnSync } = require('child_process');
            const fs = require('fs');
            const path = require('path');

            const issueNumbers = ${{ steps.fetch-issues.outputs.result }};

            if (!issueNumbers || issueNumbers.length === 0) {
              console.log('No SCAN issues to process');
              return;
            }

            console.log(`Processing ${issueNumbers.length} issues: ${issueNumbers.join(', ')}`);

            const defaultBranch = context.payload.repository.default_branch || 'main';
            console.log(`Using default branch: ${defaultBranch}`);

            for (const issueNumber of issueNumbers) {
              console.log(`\n=== Processing issue #${issueNumber} ===`);

              // Validate issue number is a positive integer
              if (!Number.isInteger(issueNumber) || issueNumber <= 0) {
                console.error(`Invalid issue number: ${issueNumber}`);
                continue;
              }

              const eventPath = `.tmp/issue-${issueNumber}-event.json`;
              const scanOutputDir = `.scan-output-${issueNumber}`;

              try {
                // Fetch the issue details
                const { data: issue } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });

                // Create event payload for the scanner
                const eventPayload = {
                  action: 'scheduled-scan',
                  issue: issue
                };

                // Create temp directory and event file
                fs.mkdirSync('.tmp', { recursive: true });
                fs.writeFileSync(eventPath, JSON.stringify(eventPayload, null, 2));

                // Create scan output directory
                fs.mkdirSync(scanOutputDir, { recursive: true });

                // Run the scan using spawn for better security
                console.log(`Running scan for issue #${issueNumber}...`);
                const scanProcess = spawnSync(
                  process.execPath,
                  ['scanner/run-scan.mjs', eventPath, scanOutputDir],
                  { encoding: 'utf8', maxBuffer: 10 * 1024 * 1024 }
                );

                if (scanProcess.error) {
                  throw new Error(`Failed to run scan: ${scanProcess.error.message}`);
                }

                const scanResult = scanProcess.stdout;
                let meta;
                try {
                  meta = JSON.parse(scanResult);
                } catch (parseError) {
                  throw new Error(`Failed to parse scan output as JSON: ${parseError.message}`);
                }
                console.log(`Scan completed:`, meta);

                if (meta.skipped) {
                  console.log(`Issue #${issueNumber} was skipped: ${meta.reason}`);
                  // Clean up temporary files
                  fs.rmSync(eventPath, { force: true });
                  fs.rmSync(scanOutputDir, { recursive: true, force: true });
                  continue;
                }

                // Prepare report paths
                const stamp = new Date().toISOString().replace(/[:.]/g, '-');
                const reportDir = `reports/issues/issue-${issueNumber}/${stamp}`;
                const summaryPath = `${reportDir}/report.json`;
                const markdownPath = `${reportDir}/report.md`;
                const csvPath = `${reportDir}/report.csv`;

                // Create report directory and copy files
                fs.mkdirSync(reportDir, { recursive: true });
                fs.copyFileSync(`${scanOutputDir}/report.json`, summaryPath);
                fs.copyFileSync(`${scanOutputDir}/report.md`, markdownPath);
                fs.copyFileSync(`${scanOutputDir}/report.csv`, csvPath);

                // Clean up temporary files
                fs.rmSync(eventPath, { force: true });
                fs.rmSync(scanOutputDir, { recursive: true, force: true });

                // Commit and push the report using spawnSync for security
                spawnSync('git', ['config', 'user.name', 'github-actions[bot]']);
                spawnSync('git', ['config', 'user.email', '41898282+github-actions[bot]@users.noreply.github.com']);
                spawnSync('git', ['add', reportDir]);

                // Check if there are changes to commit
                const statusResult = spawnSync('git', ['status', '--porcelain'], { encoding: 'utf8' });
                if (statusResult.stdout.trim()) {
                  const commitMessage = `chore(scan): scheduled scan for issue #${issueNumber}`;
                  const commitResult = spawnSync('git', ['commit', '-m', commitMessage]);
                  if (commitResult.status === 0) {
                    const pushResult = spawnSync('git', ['push', 'origin', `HEAD:${defaultBranch}`]);
                    if (pushResult.status === 0) {
                      console.log(`Report committed and pushed for issue #${issueNumber}`);
                    } else {
                      throw new Error(`Failed to push: ${pushResult.stderr}`);
                    }
                  } else {
                    throw new Error(`Failed to commit: ${commitResult.stderr}`);
                  }
                } else {
                  console.log(`No changes to commit for issue #${issueNumber}`);
                }

                // Post comment with results
                const owner = context.repo.owner;
                const repo = context.repo.repo;
                const encodedMarkdownPath = markdownPath.split('/').map(encodeURIComponent).join('/');
                const encodedCsvPath = csvPath.split('/').map(encodeURIComponent).join('/');
                const pagesUrl = `https://${owner}.github.io/${repo}/${encodedMarkdownPath}`;
                const csvPagesUrl = `https://${owner}.github.io/${repo}/${encodedCsvPath}`;
                const blobUrl = `https://github.com/${owner}/${repo}/blob/${encodeURIComponent(defaultBranch)}/${encodedMarkdownPath}`;
                const csvBlobUrl = `https://github.com/${owner}/${repo}/blob/${encodeURIComponent(defaultBranch)}/${encodedCsvPath}`;

                const body = [
                  `Scheduled scan complete for **${meta.scanTitle}**.`,
                  "",
                  `- Accepted URLs scanned: ${meta.acceptedCount}`,
                  `- Rejected URLs: ${meta.rejectedCount}`,
                  "",
                  `Report (Pages): ${pagesUrl}`,
                  `Fallback (GitHub): ${blobUrl}`,
                  `CSV (Pages): ${csvPagesUrl}`,
                  `CSV Fallback (GitHub): ${csvBlobUrl}`
                ].join("\n");

                // Retry posting comment with exponential backoff
                let commentPosted = false;
                for (let attempt = 0; attempt < 3; attempt++) {
                  try {
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: issueNumber,
                      body
                    });
                    console.log(`Comment posted to issue #${issueNumber}`);
                    commentPosted = true;
                    break;
                  } catch (commentError) {
                    console.warn(`Attempt ${attempt + 1} failed to post comment:`, commentError.message);
                    if (attempt < 2) {
                      const delay = Math.pow(2, attempt) * 1000; // 1s, 2s
                      console.log(`Retrying in ${delay}ms...`);
                      await new Promise(resolve => setTimeout(resolve, delay));
                    }
                  }
                }
                
                if (!commentPosted) {
                  console.error(`Failed to post success comment after 3 attempts`);
                }

                // Close the issue if URLs were successfully scanned
                // Note: Issues with zero accepted URLs remain open for review
                if (meta.acceptedCount > 0) {
                  let issueClosed = false;
                  for (let attempt = 0; attempt < 3; attempt++) {
                    try {
                      await github.rest.issues.update({
                        owner,
                        repo,
                        issue_number: issueNumber,
                        state: 'closed'
                      });
                      console.log(`Issue #${issueNumber} closed`);
                      issueClosed = true;
                      break;
                    } catch (closeError) {
                      console.warn(`Attempt ${attempt + 1} failed to close issue:`, closeError.message);
                      if (attempt < 2) {
                        const delay = Math.pow(2, attempt) * 1000; // 1s, 2s
                        console.log(`Retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                      }
                    }
                  }
                  
                  if (!issueClosed) {
                    console.error(`Failed to close issue after 3 attempts. Scan completed successfully but issue remains open.`);
                  }
                }

              } catch (error) {
                console.error(`Error processing issue #${issueNumber}:`, error);

                // Clean up temporary files on error
                try {
                  fs.rmSync(eventPath, { force: true });
                  fs.rmSync(scanOutputDir, { recursive: true, force: true });
                } catch (cleanupError) {
                  console.error(`Failed to clean up temporary files:`, cleanupError);
                }

                // Post error comment (no retry - best effort)
                try {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: `‚ùå Scheduled scan encountered an error: ${error.message}\n\nPlease check the [workflow logs](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details.`
                  });
                } catch (commentError) {
                  console.error(`Failed to post error comment:`, commentError.message);
                }
              }
            }
