name: Scan Request

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  contents: write
  issues: write

concurrency:
  group: scan-request-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  run-scan-request:
    if: startsWith(github.event.issue.title, 'SCAN:')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      # Timeout configuration (optional, defaults shown):
      # - FETCH_TIMEOUT_MS: Maximum time for initial HTTP fetch (default: 30000ms = 30s)
      # - PER_URL_TIMEOUT_MS: Maximum time per URL including fetch and all audits (default: 60000ms = 60s)
      # - TOTAL_SCAN_TIMEOUT_MS: Maximum total scan time (default: 3000000ms = 50min)
      # - ALFA_PAGE_TIMEOUT_MS: ALFA CLI page load timeout (default: 30000ms = 30s)
      # - ALFA_COMMAND_TIMEOUT_MS: ALFA command execution timeout (default: 180000ms = 3min)
      # - PLAYWRIGHT_NAV_TIMEOUT_MS: Playwright page navigation timeout (default: 30000ms = 30s)
      # - PLAYWRIGHT_LAUNCH_TIMEOUT_MS: Playwright browser launch timeout (default: 30000ms = 30s)
      #
      # To customize timeouts, add them to the "Run issue scan" step's env section

      - name: Persist event payload
        run: |
          mkdir -p .tmp
          cat > .tmp/issue-event.json <<'EOF'
          ${{ toJson(github.event) }}
          EOF

      - name: Run issue scan
        run: |
          mkdir -p .scan-output
          node scanner/run-scan.mjs .tmp/issue-event.json .scan-output > .scan-output/meta.json
        # Uncomment and adjust these environment variables to customize timeouts:
        # env:
        #   FETCH_TIMEOUT_MS: "30000"           # 30s for initial HTTP fetch
        #   PER_URL_TIMEOUT_MS: "60000"         # 60s per URL total
        #   TOTAL_SCAN_TIMEOUT_MS: "3000000"    # 50min total scan time
        #   ALFA_PAGE_TIMEOUT_MS: "30000"       # 30s ALFA page load
        #   ALFA_COMMAND_TIMEOUT_MS: "180000"   # 3min ALFA command execution
        #   PLAYWRIGHT_NAV_TIMEOUT_MS: "30000"  # 30s Playwright navigation
        #   PLAYWRIGHT_LAUNCH_TIMEOUT_MS: "30000" # 30s Playwright browser launch

      - name: Read scan metadata
        id: meta
        run: |
          node --input-type=module <<'NODE'
          import { appendFileSync, readFileSync } from 'node:fs';

          const meta = JSON.parse(readFileSync('.scan-output/meta.json', 'utf8'));
          const issueNumber = Number(process.env.ISSUE_NUMBER);
          const stamp = new Date().toISOString().replace(/[:.]/g, '-');
          const reportDir = `reports/issues/issue-${issueNumber}/${stamp}`;
          const summaryPath = `${reportDir}/report.json`;
          const markdownPath = `${reportDir}/report.md`;
          const csvPath = `${reportDir}/report.csv`;
          const overlapJsonPath = `${reportDir}/report-overlap.json`;
          const overlapMarkdownPath = `${reportDir}/report-overlap.md`;

          const output = process.env.GITHUB_OUTPUT;
          const lines = [
            `accepted_count=${meta.acceptedCount ?? 0}`,
            `scanned_count=${meta.scannedCount ?? meta.acceptedCount ?? 0}`,
            `skipped_due_to_timeout=${meta.skippedDueToTimeout ?? 0}`,
            `rejected_count=${meta.rejectedCount ?? 0}`,
            `scan_title=${(meta.scanTitle ?? '').replace(/\n/g, ' ')}`,
            `report_dir=${reportDir}`,
            `summary_path=${summaryPath}`,
            `markdown_path=${markdownPath}`,
            `csv_path=${csvPath}`,
            `overlap_json_path=${overlapJsonPath}`,
            `overlap_markdown_path=${overlapMarkdownPath}`,
            `stamp=${stamp}`
          ].join('\n') + '\n';

          appendFileSync(output, lines, 'utf8');
          NODE
        env:
          ISSUE_NUMBER: ${{ github.event.issue.number }}

      - name: Persist reports into repository
        run: |
          mkdir -p "${{ steps.meta.outputs.report_dir }}"
          cp .scan-output/report.json "${{ steps.meta.outputs.summary_path }}"
          cp .scan-output/report.md "${{ steps.meta.outputs.markdown_path }}"
          cp .scan-output/report.csv "${{ steps.meta.outputs.csv_path }}"
          cp .scan-output/report-overlap.json "${{ steps.meta.outputs.overlap_json_path }}"
          cp .scan-output/report-overlap.md "${{ steps.meta.outputs.overlap_markdown_path }}"

      - name: Regenerate reports.html
        run: node scanner/generate-reports-html.mjs

      - name: Commit and push report artifacts
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "${{ steps.meta.outputs.report_dir }}" reports.html
          if git diff --cached --quiet; then
            echo "No report changes to commit."
          else
            git commit -m "chore(scan): issue #${{ github.event.issue.number }} ${{ steps.meta.outputs.scan_title }}"
            
            # Retry push with rebase up to 3 times
            PUSH_SUCCESS=false
            for attempt in 1 2 3; do
              echo "Push attempt $attempt..."
              if git pull --rebase origin main && git push origin HEAD:main; then
                echo "Successfully pushed on attempt $attempt"
                PUSH_SUCCESS=true
                break
              fi
              
              # Abort rebase if it's in progress
              if git status | grep -q "rebase in progress"; then
                git rebase --abort
              fi
              
              if [ $attempt -lt 3 ]; then
                sleep $((attempt * 2))
                echo "Retrying..."
              fi
            done
            
            if [ "$PUSH_SUCCESS" = false ]; then
              echo "Failed to push after 3 attempts" >&2
              exit 1
            fi
          fi

      - name: Comment report link
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.payload.issue.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const markdownPath = process.env.MARKDOWN_PATH;
            const csvPath = process.env.CSV_PATH;
            const overlapMarkdownPath = process.env.OVERLAP_MARKDOWN_PATH;
            const acceptedCount = process.env.ACCEPTED_COUNT;
            const rejectedCount = process.env.REJECTED_COUNT;
            const pagesUrl = `https://${owner}.github.io/${repo}/${markdownPath}`;
            const csvPagesUrl = `https://${owner}.github.io/${repo}/${csvPath}`;
            const overlapPagesUrl = `https://${owner}.github.io/${repo}/${overlapMarkdownPath}`;
            const blobUrl = `https://github.com/${owner}/${repo}/blob/main/${markdownPath}`;
            const csvBlobUrl = `https://github.com/${owner}/${repo}/blob/main/${csvPath}`;
            const overlapBlobUrl = `https://github.com/${owner}/${repo}/blob/main/${overlapMarkdownPath}`;

            const body = [
              `Scan complete for **${process.env.SCAN_TITLE || context.payload.issue.title}**.`,
              "",
              `- Accepted URLs: ${acceptedCount}`,
              `- Scanned URLs: ${process.env.SCANNED_COUNT || acceptedCount}`,
            ];
            
            // Add warning if some URLs were skipped
            if (process.env.SKIPPED_DUE_TO_TIMEOUT && parseInt(process.env.SKIPPED_DUE_TO_TIMEOUT) > 0) {
              body.push(`- ‚ö†Ô∏è **${process.env.SKIPPED_DUE_TO_TIMEOUT} URLs skipped due to timeout** (scan exceeded time limit)`);
              body.push(``);
              body.push(`**üí° Tip for large URL lists:** Consider splitting into smaller batches:`);
              body.push(`- Create multiple scan issues with 100-150 URLs each, OR`);
              body.push(`- Increase the timeout by setting TOTAL_SCAN_TIMEOUT_MS in the workflow`);
              body.push(``);
            }
            
            body.push(
              `- Rejected URLs: ${rejectedCount}`,
              "",
              `Report (Pages): ${pagesUrl}`,
              `Fallback (GitHub): ${blobUrl}`,
              `CSV (Pages): ${csvPagesUrl}`,
              `CSV Fallback (GitHub): ${csvBlobUrl}`,
              `Scanner Overlap (Pages): ${overlapPagesUrl}`,
              `Scanner Overlap Fallback (GitHub): ${overlapBlobUrl}`
            );
            
            const commentBody = body.join("\n");

            // Retry posting comment with exponential backoff
            for (let attempt = 0; attempt < 3; attempt++) {
              try {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body: commentBody
                });
                console.log(`Comment posted successfully`);
                break;
              } catch (error) {
                console.warn(`Attempt ${attempt + 1} failed to post comment:`, error.message);
                if (attempt < 2) {
                  const delay = Math.pow(2, attempt) * 1000; // 1s, 2s
                  console.log(`Retrying in ${delay}ms...`);
                  await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                  throw error; // Re-throw on final attempt to fail the workflow
                }
              }
            }
        env:
          MARKDOWN_PATH: ${{ steps.meta.outputs.markdown_path }}
          CSV_PATH: ${{ steps.meta.outputs.csv_path }}
          OVERLAP_MARKDOWN_PATH: ${{ steps.meta.outputs.overlap_markdown_path }}
          ACCEPTED_COUNT: ${{ steps.meta.outputs.accepted_count }}
          SCANNED_COUNT: ${{ steps.meta.outputs.scanned_count }}
          SKIPPED_DUE_TO_TIMEOUT: ${{ steps.meta.outputs.skipped_due_to_timeout }}
          REJECTED_COUNT: ${{ steps.meta.outputs.rejected_count }}
          SCAN_TITLE: ${{ steps.meta.outputs.scan_title }}

      - name: Close issue after scan
        if: ${{ steps.meta.outputs.accepted_count != '0' }}
        uses: actions/github-script@v7
        with:
          script: |
            // Retry closing issue with exponential backoff
            for (let attempt = 0; attempt < 3; attempt++) {
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number,
                  state: 'closed'
                });
                console.log(`Issue closed successfully`);
                break;
              } catch (error) {
                console.warn(`Attempt ${attempt + 1} failed to close issue:`, error.message);
                if (attempt < 2) {
                  const delay = Math.pow(2, attempt) * 1000; // 1s, 2s
                  console.log(`Retrying in ${delay}ms...`);
                  await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                  throw error; // Re-throw on final attempt to fail the workflow
                }
              }
            }